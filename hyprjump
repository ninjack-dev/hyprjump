#!/usr/bin/env bash

set -u

HYPRJUMP_DIR="${XDG_RUNTIME_DIR}/hyprjump/${HYPRLAND_INSTANCE_SIGNATURE}"
HYPRJUMP_SOCKET="${HYPRJUMP_DIR}/.socket.sock"
HYPRLAND_EVENT_SOCKET="${XDG_RUNTIME_DIR}/hypr/${HYPRLAND_INSTANCE_SIGNATURE}/.socket2.sock"

declare -ag JUMP_LIST=()
declare -g ACTIVE_ADDRESS=""

print_help() {
  echo " Usage: hyprjump <command> <subcommand>"
  echo ""
  echo " Commands:"
  echo "   run           Runs the watcher process responsible for maintaining the jumplist"
  echo "   jump          Jumps to the next/previous window in the jumplist based on subcommand (default: next)"
  echo "   Subcommands:"
  echo "     up, next    Jumps to the next window in the jumplist (i.e. the window focused after this one)"
  echo "     down, prev  Jumps to the previous window in the jumplist (i.e. the window focused before this one)"
  echo "   init          Initializes the binds associated with tag mode"
  echo "   help          Shows this help text"
}

# TODO: Replace `hyprctl` with a string builder, call at end with `--batch`
# Maybe also look into unbinding existing, identical binds?
inititialize_mark_modes() {
  hyprctl keyword bindd '$mainMod,m,Enter mark mode,submap,mark_mode' > /dev/null
  hyprctl keyword submap mark_mode > /dev/null
  for char in {a..z}; do
    hyprctl keyword bindd ",$char,Tag currently-focused window with $char,tagwindow,-$char tag:$char" > /dev/null
    hyprctl keyword bindd ",$char,Tag currently-focused window with $char,tagwindow,+$char" > /dev/null
    hyprctl keyword bindd ",$char,Tag currently-focused window with $char,submap,reset" > /dev/null
  done
  hyprctl keyword bindd ',Escape,Exit mark mode early,submap,reset' > /dev/null
  hyprctl keyword submap reset > /dev/null

  hyprctl keyword bindd '$mainMod,apostrophe,Enter jump mode,submap,jump_mode' > /dev/null
  hyprctl keyword submap jump_mode > /dev/null
  for char in {a..z}; do
    hyprctl keyword bindd ",$char, Jump to window marked with $char, focuswindow, tag:$char" > /dev/null
    hyprctl keyword bindd ",$char, Jump to window marked with $char, submap, reset" > /dev/null
  done
  for int in {1..10}; do
    declare -l desc_int
    case $int in
      1)
        desc_int=""
        ;;
      2)
        desc_int="2nd "
        ;;
      3)
        desc_int="3rd "
        ;;
      *)
        desc_int="${int}th "
        ;;
    esac
    hyprctl keyword bindd ",${int: -1},Jump to the ${desc_int}most recently focused window, exec, sh -c \"hyprctl dispatch focuswindow address:\$(hyprctl -j clients | jq -r '.[] | select(.focusHistoryID == $int) | .address')\"" > /dev/null
    hyprctl keyword bindd ",${int: -1},Jump to the ${desc_int}most recently focused window, submap, reset" > /dev/null
  done
  hyprctl keyword bindd ',Escape,Exit jump mode early,submap,reset' > /dev/null
  hyprctl keyword submap reset > /dev/null
}

ensure_dirs() {
  mkdir -p "${HYPRJUMP_DIR}"
}

update_state() {
  readarray -t JUMP_LIST < <(
    hyprctl -j clients | jq -r 'sort_by(.focusHistoryID) | .[].address'
  )
  ACTIVE_ADDRESS="${JUMP_LIST[0]}"
}

handle_hyprland_event() {
  local line="$1"
  [[ $line == activewindowv2* || -z $ACTIVE_ADDRESS ]] || return 0
  local address="${line/activewindowv2>>/0x}"
  if [[ $address != "$ACTIVE_ADDRESS" ]]; then
    ACTIVE_ADDRESS=""
  fi
}

focus_address() {
  local addr="$1"
  [[ -n $addr ]] || return 1
  ACTIVE_ADDRESS="$addr"
  hyprctl dispatch focuswindow "address:${ACTIVE_ADDRESS}" > /dev/null 2>&1
}

jump_up() {
  [[ -z "$ACTIVE_ADDRESS" ]] && update_state
  local i
  for ((i = 0; i < ${#JUMP_LIST[@]}; i++)); do
    if [[ ${JUMP_LIST[i]} == "$ACTIVE_ADDRESS" ]]; then
      ((i > 0)) && focus_address "${JUMP_LIST[$i - 1]}"
      return 0
    fi
  done
}

jump_down() {
  [[ -z "$ACTIVE_ADDRESS" ]] && update_state
  local i
  for ((i = 0; i < ${#JUMP_LIST[@]}; i++)); do
    if [[ ${JUMP_LIST[i]} == "$ACTIVE_ADDRESS" ]]; then
      ((i + 1 < ${#JUMP_LIST[@]})) && focus_address "${JUMP_LIST[$i + 1]}"
      return 0
    fi
  done
}

handle_command() {
  case "$1" in
    jump_up) jump_up ;;
    jump_down) jump_down ;;
  esac
}

# Send commands to control socket
cmd() {
  printf "%s\n" "$1" | socat - UNIX-CONNECT:"$HYPRJUMP_SOCKET" || echo "Could not write to control socket!"
}

# --- Daemon Logic ---
# It's seemingly impossible to read from multiple file descriptors in parallel (if there is a way, please make an issue/PR!!)
# As such, we take our event streams and merge them into a single FD (EVENT_BUS), prepending the event type to each line.
# Event types are as follows:
# - EVENT: An event from the Hyprland socket
# - COMMAND: A command for Hyprjump

# For these two feeds, for some reason, piping to `sed` to prepend the type had no output. This was the only way I could make it work.
start_event_feed() {
  socat -u UNIX-CONNECT:"$HYPRLAND_EVENT_SOCKET" - \
    | while read -r event; do printf "%s\n" "EVENT $event"; done
}

start_command_feed() {
  socat -u UNIX-LISTEN:"$HYPRJUMP_SOCKET",unlink-early,fork - \
    | while read -r command; do printf "%s\n" "COMMAND $command"; done
}

start_event_bus() {
  exec {EVENT_BUS}< <(
    start_command_feed &
    start_event_feed &
    wait
  )
  BUS_PID=$!
}

begin_daemon() {
  ensure_dirs

  if ls "$HYPRJUMP_SOCKET" > /dev/null 2>&1; then
    hyprjump_pids=$(pgrep --full ".*hyprjump.*run.*")
    hyprjump_pid_count=$(wc -l <<< "$hyprjump_pids")

    EXPECTED_PID_COUNT=7 # Expected count for a daemon process is 6, +1 for this current one
    if [[ $hyprjump_pid_count -ge $EXPECTED_PID_COUNT ]]; then
      echo "Hyprjump \"daemon\" is already running"
      exit 1
    else
      rm -f "$HYPRJUMP_SOCKET"
    fi
  fi

  update_state
  start_event_bus

  trap '
    [[ -n "${BUS_PID-}" ]] && kill "$BUS_PID"   2>/dev/null
    rm -f $HYPRJUMP_SOCKET
  ' EXIT

  while read -r -u "$EVENT_BUS" event; do
    case "$event" in
      EVENT\ *) handle_hyprland_event "${event#EVENT }" ;;
      COMMAND\ *) handle_command "${event#COMMAND }" ;;
      *) printf "Unknown event type: %s" "${event%% *}" ;;
    esac
  done
}

main() {
  if [[ $# -eq 0 ]]; then
    print_help
    exit 1
  fi

  case "$1" in
    run)
      begin_daemon
      exit
      ;;
    jump)
      shift
      while [[ $# -gt 0 ]]; do
        case "$1" in
          up | next) cmd "jump_up" ;;
          down | prev) cmd "jump_down" ;;
          *)
            printf 'Unknown jump direction: %s\n' "$1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
    init)
      shift
      inititialize_mark_modes
      ;;
    help)
      print_help
      ;;
    *)
      printf 'Unknown command: %s\n' "$1" >&2
      exit 1
      ;;
  esac
}

main "$@"
