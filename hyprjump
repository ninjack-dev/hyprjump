#!/usr/bin/env bash

HYPRJUMP_DIR="${XDG_RUNTIME_DIR}/hyprjump/${HYPRLAND_INSTANCE_SIGNATURE}"
HYPRJUMP_SOCKET="${HYPRJUMP_DIR}/.socket.sock"
HYPRLAND_EVENT_SOCKET="${XDG_RUNTIME_DIR}/hypr/${HYPRLAND_INSTANCE_SIGNATURE}/.socket2.sock"

declare -ag JUMP_LIST=()
declare -g CURRENT_INDEX

# Hyprland is... interesting. I spent many hours debugging this:
# Basically, if I have these three adjacent windows:
# -----------
# [A] [B] [C] <-- focused
# -----------
# And I focuswindow A, my event log will look like this:
# activewindowv2>>B
# activewindowv2>>A
#
# but if I have:
# -----------
# [B] [A] [C] <--focused
# -----------
# and I run the same, I get:
# activewindowv2>>A
#
# In summary, the focuswindow dispatcher triggers a focus event for all windows in between the current and target, maybe due to the mouse
# As such, we need this variable to effectively ignore events until we hit the one we're expecting. I don't think it should cause any issues.
declare -g IN_TRANSITION=0

print_help() {
  echo " Usage: hyprjump <command> <subcommand>"
  echo ""
  echo " Commands:"
  echo "   run           Runs the watcher process responsible for maintaining the jumplist"
  echo "   jump          Jumps to the next/previous window in the jumplist based on subcommand (default: next)"
  echo "   Subcommands:"
  echo "     up, next    Jumps to the next window in the jumplist (i.e. the window focused after this one)"
  echo "     down, prev  Jumps to the previous window in the jumplist (i.e. the window focused before this one)"
  echo "   init          Initializes the binds associated with tag mode"
  echo "   help          Shows this help text"
}

# TODO: Replace `hyprctl` with a string builder, call at end with `--batch`
# Maybe also look into unbinding existing, identical binds?
inititialize_mark_modes() {
  hyprctl keyword bindd '$mainMod,m,Enter mark mode,submap,mark_mode' > /dev/null
  hyprctl keyword submap mark_mode > /dev/null
  for char in {a..z}; do
    hyprctl keyword bindd ",$char,Tag currently-focused window with $char,tagwindow,-$char tag:$char" > /dev/null
    hyprctl keyword bindd ",$char,Tag currently-focused window with $char,tagwindow,+$char" > /dev/null
    hyprctl keyword bindd ",$char,Tag currently-focused window with $char,submap,reset" > /dev/null
  done
  hyprctl keyword bindd ',Escape,Exit mark mode early,submap,reset' > /dev/null
  hyprctl keyword submap reset > /dev/null

  hyprctl keyword bindd '$mainMod,apostrophe,Enter jump mode,submap,jump_mode' > /dev/null
  hyprctl keyword submap jump_mode > /dev/null
  for char in {a..z}; do
    hyprctl keyword bindd ",$char, Jump to window marked with $char, focuswindow, tag:$char" > /dev/null
    hyprctl keyword bindd ",$char, Jump to window marked with $char, submap, reset" > /dev/null
  done
  for int in {1..10}; do
    declare -l desc_int
    case $int in
      1)
        desc_int=""
        ;;
      2)
        desc_int="2nd "
        ;;
      3)
        desc_int="3rd "
        ;;
      *)
        desc_int="${int}th "
        ;;
    esac
    hyprctl keyword bindd ",${int: -1},Jump to the ${desc_int}most recently focused window, exec, sh -c \"hyprctl dispatch focuswindow address:\$(hyprctl -j clients | jq -r '.[] | select(.focusHistoryID == $int) | .address')\"" > /dev/null
    hyprctl keyword bindd ",${int: -1},Jump to the ${desc_int}most recently focused window, submap, reset" > /dev/null
  done
  hyprctl keyword bindd ',Escape,Exit jump mode early,submap,reset' > /dev/null
  hyprctl keyword submap reset > /dev/null
}

ensure_dirs() {
  mkdir -p "${HYPRJUMP_DIR}"
}

update_state() {
  readarray -t JUMP_LIST < <(
    hyprctl -j clients | jq -r 'sort_by(.focusHistoryID) | .[].address'
  )
  CURRENT_INDEX=0
}

handle_hyprland_event() {
  local line="$1"
  [[ $line == activewindowv2* && -n ${JUMP_LIST[$CURRENT_INDEX]} ]] || return 0
  local address="${line/activewindowv2>>/0x}"
  if [[ $IN_TRANSITION -eq 1 ]]; then
    if [[ $address == "${JUMP_LIST[$CURRENT_INDEX]}" ]]; then
      IN_TRANSITION=0
    fi
    return
  fi
  if [[ $address != "${JUMP_LIST[$CURRENT_INDEX]}" ]]; then
    CURRENT_INDEX=-1
  fi
}

focus_address() {
  [[ -n $1 ]] || return 1
  IN_TRANSITION=1
  hyprctl dispatch focuswindow "address:$1" > /dev/null 2>&1
}

jump_up() {
  [[ $CURRENT_INDEX -eq -1 ]] && update_state
  ((CURRENT_INDEX > 0)) && ((CURRENT_INDEX--))
  focus_address "${JUMP_LIST[$CURRENT_INDEX]}"
}

jump_down() {
  [[ $CURRENT_INDEX -eq -1 ]] && update_state
  ((CURRENT_INDEX + 1 < ${#JUMP_LIST[@]})) && ((CURRENT_INDEX++))
  focus_address "${JUMP_LIST[$CURRENT_INDEX]}"
}

handle_command() {
  case "$1" in
    jump_up) jump_up ;;
    jump_down) jump_down ;;
  esac
}

cmd() {
  printf "%s\n" "$1" | socat - UNIX-CONNECT:"$HYPRJUMP_SOCKET" || echo "Could not write to control socket!"
}

# --- Daemon Logic ---
# It's seemingly impossible to read from multiple file descriptors in parallel (if there is a way, please make an issue/PR!!)
# As such, we take our event streams and merge them into a single FD (EVENT_BUS), prepending the event type to each line.
# Event types are as follows:
# - EVENT: An event from the Hyprland socket
# - COMMAND: A command for Hyprjump

start_window_event_feed() {
  socat -u UNIX-CONNECT:"$HYPRLAND_EVENT_SOCKET" - | sed -u 's/^/EVENT /'
}

start_command_feed() {
  socat -u UNIX-LISTEN:"$HYPRJUMP_SOCKET",unlink-early,fork - | sed -u 's/^/COMMAND /'
}

start_event_bus() {
  exec {EVENT_BUS}< <(
    start_command_feed &
    start_window_event_feed &
    wait
  )
  BUS_PID=$!
}

begin_daemon() {
  ensure_dirs

  if ls "$HYPRJUMP_SOCKET" > /dev/null 2>&1; then
    hyprjump_pids=$(pgrep --full ".*hyprjump.*run.*")
    hyprjump_pid_count=$(wc -l <<< "$hyprjump_pids")

    EXPECTED_PID_COUNT=5 # Expected count for a daemon process is 4, +1 for this current one
    if [[ $hyprjump_pid_count -ge $EXPECTED_PID_COUNT ]]; then
      echo "Hyprjump \"daemon\" is already running"
      exit 1
    else
      rm -f "$HYPRJUMP_SOCKET"
    fi
  fi

  update_state
  start_event_bus

  trap '
    [[ -n "${BUS_PID-}" ]] && kill "$BUS_PID"   2>/dev/null
    rm -f $HYPRJUMP_SOCKET
  ' EXIT

  while read -r -u "$EVENT_BUS" event; do
    case "$event" in
      EVENT\ *) handle_hyprland_event "${event#EVENT }" ;;
      COMMAND\ *) handle_command "${event#COMMAND }" ;;
      *) printf "Unknown event type: %s" "${event%% *}" ;;
    esac
  done
}

main() {
  if [[ $# -eq 0 ]]; then
    print_help
    exit 1
  fi

  case "$1" in
    run)
      begin_daemon
      exit
      ;;
    jump)
      shift
      while [[ $# -gt 0 ]]; do
        case "$1" in
          up | next) cmd "jump_up" ;;
          down | prev) cmd "jump_down" ;;
          *)
            printf 'Unknown jump direction: %s\n' "$1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
    init)
      shift
      inititialize_mark_modes
      ;;
    help)
      print_help
      ;;
    *)
      printf 'Unknown command: %s\n' "$1" >&2
      exit 1
      ;;
  esac
}

main "$@"
